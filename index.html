<!DOCTYPE html>
<html lang="en">

<head>
  <title>JavaScript in the Wild</title>
</head>

<body>
  <h1>JavaScript in the Wild MP</h1>
  <p>Please load this file in VSCode and Chrome, and open the Console in Chrome Dev Tools.</p>
  <p>Work through the challenges found inside the script tag in this document,
    until the Console reports all tests passing.</p>

  <script>
    // In CHALLENGES 1-7, you will fill in some functions.

    // To do this, translate each 🧠 set of instructions into a working function.
    // ❗ Functions are already scaffolded as arrow functions.
    // ❗ You must add the parameters to the function that you need
    // ❗ Watch the Guided Project to learn proper debugging technique.

    // 👉 CHALLENGE 1
    // 🧠 The function swapper takes an array and swaps its first and last elements.
    // 🧠 If the array has fewer than two elements the function returns the string "No swap performed".
    // 🧠 Examples of usage:
    // swapper(['a', 'b']) // should return ['b', 'a']
    // swapper(['a', 'b', 'c']) // should return ['c', 'b', 'a']
    // swapper(['a']) // should return "No swap performed"
    // ❗ Notes
    // 🧠 Try using destructuring to grab a reference to the first element of the array
    // 🧠 Try using the at method of arrays to grab the last element
    // Step 1: Pass array
    // Step 2: Deal with your edge case logic: if the length of the array is < 2: return 'No swap performed'
    // Step 3: Create a variables to grab all the necessary elements:
        // 3a: to grab the first element with destructuring
        // 3b: Use .at() method to grab the last element & assign to a variable
        // 3c: Use .slice () to grab al the elements in the middle & assign to a variable
    // Step 4: Construct the result array with elements swapped: 
        // 4a: assign result to an array, 
        // 4b: pass in lastElement, all of the REST of the middle elements, and the firstElement
    // Step 6: Return result
    const swapper = (arr) => {
      if (arr.length < 2) {
        return 'No swap performed'
      }
      const [firstElement] = arr // this is destructuring - if it wasn't it would be const [first] = arr[0]
      const lastElement = arr.at(-1) // this is NOT destructuring
      const midElements = arr.slice(1, -1)
      // console.log(firstElement)
      // console.log(lastElement)
      // console.log(midElements)
      let result = [lastElement, ...midElements, firstElement]
      return result
    }

    // Gab's Solution
    // const swapper = (arr) => {
    //   if (arr.length < 2) {
    //     return 'No swap performed'
    //   }
    //   let [first] = arr
    //   let last = arr.at(-1)

    //   arr[0] = last // assigning the first element in array to the last element in the array
    //   arr[arr.length-1] = first // assigning the last element in the array to the first var

    //   return arr
    // }


    // 👉 CHALLENGE 2
    // 🧠 The function headAndTail takes an array as its argument.
    // 🧠 It returns a new array with two elements.
    // 🧠 The first element is the head of the original array.
    // 🧠 The second element is the tail of the original array.
    // 🧠 If the given array is empty, return the string "This array is empty" - edge case
    // 🧠 Examples of usage:
    // headAndTail([1, 2, 3]) // should return [1, [2, 3]]
    // ❗ Notes
    // 🧠 Try using destructuring and the spread operator to get the head and tail.
    // 🧠 Try using the ternary operator instead of a conditional statement when deciding what to return.
    // 🧠 So instead of doing `if ('foo') return 'bar' else return 'baz'` do `return 'foo' ? 'bar' : 'baz'`
    // 🧠 The above recommendations allow to write the whole function body in just two clean lines!
    // Step 1: Pass array argument
    // Step 2: Add edge case logic with ternary operators: 
      // 2a: return the length of the array if it striclty equals 0 
      // 2b: ? 'This array is empty'
      // 2c: : [array at index 0, slice array at 1]

    // const headAndTail = (arr) => {
    //   return arr.length === 0
    //   ? 'This array is empty'
    //   : [arr[0], arr.slice(1)]
    //   }
      
    // Gab's Solution
    const headAndTail = (nums) => {
      let [head, ...tail] = nums // destructuring and gathering the rest in a pattern from the nums array
      return nums.length // if the length of nums array is truthy
      ? [head, tail] // return head & tail
      : 'This array is empty' // else return string
    }
    

    // 👉 CHALLENGE 3
    // 🧠 The function devGreet takes an isFrontend Boolean, and an isHappy Boolean, as arguments.
    // 🧠 Examples of usage:
    // devGreet(true, true) // should return "Hey, I am a frontend dev and I am happy"
    // devGreet(true, false) // should return "Hey, I am a frontend dev and I am sad"
    // devGreet(false, true) // should return "Hey, I am a backend dev and I am happy"
    // devGreet(false, false) // should return "Hey, I am a backend dev and I am sad"
    // ❗ Notes
    // 🧠 Use ternary expressions to construct the string.
    // Note: Ternary Syntax: condition ? trueExpression : falseExpression;
    // Step 1: Pass arguments
    // Step 2: check isFrontend condition : To Evaluate if isFrontend is true: return the value of isFrontend
    // Step 3: Contruct the frontend response
      // 3a: use a template literal with back tics to dynamically represent isHappy boolean
      // 3b: inside the template literal, use another ternary operator to evaluate ? for isHappy (if )'happy' use : (else) 'sad'
    // Step 4: Construct the backend response
      // 4a: use : operator to check the backend condtion 
      // 4b: and repeat steps 3a, 3b above

    // const devGreet = (isFrontend, isHappy) => {
    //  return isFrontend
    //   ? `Hey, I am a frontend dev and I am ${isHappy ? 'happy' : 'sad'}`
    //   : `Hey, I am a backend dev and I am ${isHappy  ? 'happy': 'sad'}`
    // }

    // Gab's Solution
    const devGreet = (isFrontend, isHappy) => {
      return `Hey, I am a ${isFrontend ? 'frontend' : 'backend'} dev and I am ${isHappy ? 'happy' : 'sad'}` // destructuring arrays
    }

    // 👉 CHALLENGE 4
    // 🧠 The function recognize takes an object representing a user.
    // 🧠 If the object has a name property, return a string in the format "<name> Rules!".
    // 🧠 If there is no name prop, return the string "Hidden Person Rocks!"
    // 🧠 Examples of usage:
    // recognize({ name: 'Katherine Johnson' }) // should return "Katherine Johnson Rules!"
    // recognize({}) // should return "Hidden Person Rocks!"
    // ❗ Notes
    // 🧠 Try using destructuring to grab the name, and a return followed by a ternary expression.
    // Step 1: Pass in the destructured name property on the user as an argument
    // Step 2: Return the name property and add ternary logic
        // if (?) there is a name return "<name> Rules!"
        // else (:) return "Hidden Person Rocks!"
    const recognize = ({ name }) => { // destructuring objects
      return name
      ? `${name} Rules!`
      : 'Hidden Person Rocks!'
    }

    // // Gab's Solution
    // const recognize = (person) => {
    //   // const name = person.name
    //   const { name } = person // destructured version of above line
    //   return name 
    //   ? `${name} Rules!`
    //   : 'Hidden Person Rocks!'
    // }

    // 👉 CHALLENGE 5
    // 🧠 The function processBooleans takes an array of Booleans represented using integers (1/0 instead of true/false)
    // 🧠 It should return a new array containing strings ("Y"/"N")
    // 🧠 Example of usage:
    // processBooleans([1, 0, 0, 1, 0]) // should return ["Y", "N", "N", "Y", "N"]
    // ❗ Notes
    // 🧠 Using map, arrow function syntax, and the ternary, you can make this function a short one-liner
    // Step 1: Pass the booleanArray
    // Step 2: Map over the booleans Array
    // Step 3: Define the arrow function for mapping
    // Step 4: Evaluate the condition
    // Step 5: Return the corresponding string
    // Step 6: Crate the new array
    // Step 7: Test in the console by calling the function with some arguments
    // const processBooleans = (booleansArr) => {
    //   return booleansArr.map(boolean => boolean === 1 ? "Y" : "N")
    // }

    // Gab's Solution
    const processBooleans = bools => bools.map(int => int ? 'Y' : 'N') // if int is truthy return 'Y', else 'N', and note with a single arrow function argument, we don't need ()

    // 👉 CHALLENGE 6
    // 🧠 The function reverseString takes a string as its argument, and returns it reversed.
    // 🧠 If the string is a palindrome though, return the string "It's a palindrome!"
    // 🧠 Examples of usage:
    // reverseString('Hello, World') // should return "dlroW ,olleH"
    // ❗ Notes
    // 🧠 Research on your own what a palindrome is.
    // 🧠 Split the string but do not use the reverse method of arrays. Let's do it manually.
    // 🧠 We suggest using a for loop. Research how to loop backwards over an array, starting at the last element.
    // 🧠 Use a ternary in the return statement.
    // Step 1: Pass the string
    // Step 2: Split the string into an array of characters
    // Step 3: Declare an empty array for the returned reversed array
    // Step 4: Reverse the array using a for loop
      // 4a: let i = the length of the split string var - 1
      // 4b: if i is greater than or = 0
      // 4c: decrease the value of i by 1
    // Step 5: push charArray at the index into the reversedArray
    // Step 6: join the reversed array back into a string, assign to a var
    // Step 7: Check if the original string is the same as the reversed string using ternaries

    // const reverseString = (str) => {
    //   const charArray = str.split('') // note when you need to go char by char .split() is a good idea
    //   let reversedArray = [];
    //   for (let i = charArray.length - 1; i >=0; i--) { // starting at the last index of the array and working backwards
    //     reversedArray.push(charArray[i]);
    //   }
    //   const reversedStr = reversedArray.join('');

    //   return str === reversedStr 
    //   ? `It's a palindrome!`
    //   : reversedStr
    // }

    // Gab's Solution
    const reverseString = (str) => {
      const split = str.split('') // split the string into an array of chars
      const result = [] // assign result array for reverse string
      for (let i = split.length - 1; i >= 0; --i) { // looping backwards
        let char = split[i] // checking if indices are gathered and looped correctly
        //console.log(char)
        result.push(char) // pushing individual chars into the result array 1 by 1 backwards
      }
       const rejoined = result.join(''); // return the result array in a joined string; assign to a variable to prep for ternary if/else statement
       return (str === rejoined) // if string === rejoined it's a palindrome, else return the rejoined string
       ? `It's a palindrome!`
       : rejoined
    }

    // 👉 CHALLENGE 7
    // 🧠 The function zip receives three arrays as arguments. The three arrays are of the same length (which could be any length).
    // 🧠 Array 1 contains names, array 2 contains year numbers, and array 3 contains Booleans.
    // 🧠 The zip function returns an array of objects
    // 🧠 Each object inside the returned array is constructed combining the information from arrays 1, 2, 3.
    // 🧠 Each object has three props: `name`, `born` and `jsLover`.
    // 🧠 Examples of usage:
    // zip(['Joe', 'Anna'], [1987, 1955], [true, false])
    //   should return [{ name: 'Joe', born: '1987', jsLover: true }, { name: 'Anna', born: 1955, jsLover: false }]
    // ❗ Notes
    // 🧠 Even though object properties have no particular order, to avoid confusing
    // the test runner, please set in each object first name, then age, and finally jsLover.
    // Step 1: Pass 3 arrays
    // Step 2: Declare result array
    // Step 3: loop over the arrays
    // Step 4: Create an object inside the loop (note: be sure to use the keys above exactly)
      // 4a: set name to name at index
      // 4b: set years to years at index 
      // 4c: set jsLover to booleans at index
    // Step 5: Push the object into result (after the for loop)
    // Step 6: return th efinal result array
    // const zip = (names, years, booleans) => {
    //   let result = [];

    //   for (let i = 0; i < names.length; i++) {
    //     let obj = {
    //       name: names[i],
    //       born: years[i],
    //       jsLover: booleans[i]
    //     };
    //     result.push(obj);
    //   }
    //   return result;
    // }

    // Gab's Solution
    const zip = (names, years, jsLovers) => {
      let result = []
      names.forEach ((name, idx) => {
        let person = {
          name: name,
          born: years[idx],
          jsLover: jsLovers[idx],
        }
        result.push(person)
      })
      return result
    }


    // 🧪 TESTS, do not work below this line
    // 🧪 TESTS, do not work below this line
    // 🧪 TESTS, do not work below this line
    runTests('CHALLENGE 1 - swapper', swapper, [
      [[['a', 'b']], ['b', 'a']],
      [[['a', 'b', 'c']], ['c', 'b', 'a']],
      [[['a', 'b', 'c', 'd']], ['d', 'b', 'c', 'a']],
      [[['a']], "No swap performed"],
      [[[]], "No swap performed"],
    ])
    runTests('CHALLENGE 2 - headAndTail', headAndTail, [
      [[['a', 'b']], ['a', ['b']]],
      [[['a', 'b', 'c']], ['a', ['b', 'c']]],
      [[['a', 'b', 'c', 'd']], ['a', ['b', 'c', 'd']]],
      [[['a']], ['a', []]],
      [[[]], "This array is empty"],
    ])
    runTests('CHALLENGE 3 - devGreet', devGreet, [
      [[true, true], "Hey, I am a frontend dev and I am happy"],
      [[true, false], "Hey, I am a frontend dev and I am sad"],
      [[false, true], "Hey, I am a backend dev and I am happy"],
      [[false, false], "Hey, I am a backend dev and I am sad"],
    ])
    runTests('CHALLENGE 4 - recognize', recognize, [
      [[{ name: 'Katherine Johnson' }], "Katherine Johnson Rules!"],
      [[{ name: 'Gertrude Elion', born: 1918 }], "Gertrude Elion Rules!"],
      [[{ nobelPrize: 1986 }], "Hidden Person Rocks!"],
    ])
    runTests('CHALLENGE 5 - processBooleans', processBooleans, [
      [[[1, 0, 0, 1, 0, 1]], ["Y", "N", "N", "Y", "N", "Y"]],
      [[[0, 1, 0, 1, 1]], ["N", "Y", "N", "Y", "Y"]],
      [[[]], []],
    ])
    runTests('CHALLENGE 6 - reverseString', reverseString, [
      [['Hello, World'], 'dlroW ,olleH'],
      [['Personal Access Token'], 'nekoT sseccA lanosreP'],
      [['tesla'], 'alset'],
      [['rotator'], "It's a palindrome!"],
      [['tenet'], "It's a palindrome!"],
      [['axa'], "It's a palindrome!"],
    ])
    const unzipped1 = [['Alla', 'Josh', 'Byron'], [1995, 1988, 1996], [true, true, false]]
    const zipped1 = [
      { name: 'Alla', born: 1995, jsLover: true },
      { name: 'Josh', born: 1988, jsLover: true },
      { name: 'Byron', born: 1996, jsLover: false },
    ]
    const unzipped2 = [['Joe', 'Anna'], [1987, 1955], [true, false]]
    const zipped2 = [
      { name: 'Joe', born: 1987, jsLover: true },
      { name: 'Anna', born: 1955, jsLover: false },
    ]
    runTests('CHALLENGE 7 - zip', zip, [
      [unzipped1, zipped1],
      [unzipped2, zipped2],
    ])
    function runTests(testName, func, tests) {
      let results = []
      tests.forEach(test => {
        const argsList = test[0]
        const expected = JSON.stringify(test[1])
        const actual = JSON.stringify(func.apply(null, JSON.parse(JSON.stringify(argsList))))
        results.push([argsList, expected, actual])
      })
      console.log('\n' + testName)
      if (results.every(result => result[1] === result[2])) console.log('\t✅ All tests pass')
      else results.forEach((result, idx) => {
        if (result[1] === result[2]) console.log(`\t✅ Test ${idx + 1} passes`)
        else console.log(`\t❌ Test ${idx + 1} fails: ${func.name}(${result[0]
          .map(JSON.stringify)}) should return ${result[1]} but returns ${result[2]}`)
      })
    }
  </script>
</body>

</html>
